xquery version "1.0" encoding "UTF-8";

(: This file was generated on Sat Dec  3, 2011 01:37 by REx v5.10 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: patterns.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the patterns grammar.
 :)
module namespace p="patterns";

declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  39, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 2, 2, 2, 2,
  4, 5, 6, 7, 2, 2, 8, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11, 2, 2, 2, 2, 2, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 2, 14, 2, 2, 13, 2, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 13, 13, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 13, 2, 38, 2, 2, 2
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 279, 311, 371, 403, 908, 339, 771, 771, 435, 467, 499, 531, 563, 609, 882, 577, 669, 771, 771, 771, 771, 771,
  771, 771, 771, 771, 771, 771, 771, 701, 247, 777, 637, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771,
  771, 771, 733, 765, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771,
  771, 771, 771, 771, 771, 771, 771, 771, 771, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809,
  809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809,
  809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809,
  809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 821, 771,
  771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 771, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809,
  809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809, 809,
  809, 809, 809, 809, 809, 809, 809, 809, 853, 940, 949, 941, 941, 957, 965, 1107, 973, 984, 1269, 1269, 1003, 1023,
  1031, 1039, 1047, 992, 992, 992, 992, 992, 992, 993, 992, 1269, 1269, 985, 1269, 1269, 1269, 985, 1269, 1269, 986,
  986, 1269, 1269, 1269, 1269, 986, 986, 1269, 1381, 1269, 1269, 1269, 986, 1269, 1269, 1269, 1269, 1269, 1269, 1060,
  1124, 1236, 987, 1087, 988, 1269, 987, 1236, 987, 1269, 1269, 1269, 1269, 1269, 1269, 1013, 985, 1268, 1267, 1269,
  1269, 1269, 1269, 1269, 985, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 988, 1391, 1269, 1269, 1269, 1269, 1198,
  1394, 1269, 1269, 1269, 992, 992, 992, 992, 992, 992, 992, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269,
  1269, 991, 992, 1393, 990, 992, 1113, 992, 992, 992, 992, 992, 1268, 1269, 1269, 989, 1121, 1317, 1112, 992, 1107,
  1113, 1121, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1015, 1269, 985, 1132, 1107, 1150, 1211, 1107, 1113, 1107,
  1107, 1107, 1107, 1107, 1107, 1107, 1107, 1109, 992, 992, 992, 1113, 992, 992, 992, 1361, 1246, 1269, 1269, 1266,
  1269, 1269, 1269, 1269, 985, 985, 1380, 1267, 1269, 988, 992, 1268, 1060, 1269, 1269, 1269, 1269, 1269, 1269, 1269,
  1269, 1268, 1060, 1269, 1269, 1269, 1269, 1069, 992, 1269, 1269, 1269, 1269, 1269, 1269, 1086, 1095, 1269, 1269, 1269,
  1087, 986, 990, 1418, 1269, 1269, 1269, 1269, 1269, 1269, 1169, 1107, 1109, 1212, 1269, 1155, 1107, 992, 992, 1418,
  1086, 1014, 1269, 1269, 1267, 1196, 1207, 1141, 1158, 993, 1222, 1155, 1107, 990, 992, 1233, 1256, 1014, 1269, 1269,
  1267, 1370, 1207, 1161, 1158, 992, 1244, 994, 1107, 1254, 992, 1418, 1245, 1266, 1269, 1269, 1267, 1264, 1169, 1305,
  1078, 992, 992, 1180, 1107, 992, 992, 1418, 1086, 1014, 1269, 1269, 1267, 1011, 1169, 1213, 1158, 994, 1222, 1098,
  1107, 992, 992, 1188, 1277, 1293, 1289, 1199, 1277, 1123, 1098, 1214, 1211, 993, 992, 993, 1107, 992, 992, 1418, 1060,
  1267, 1269, 1269, 1267, 1061, 1098, 1306, 1211, 995, 992, 1098, 1107, 992, 992, 1188, 1060, 1267, 1269, 1269, 1267,
  1061, 1098, 1306, 1211, 995, 1407, 1098, 1107, 992, 992, 1188, 1060, 1267, 1269, 1269, 1267, 1269, 1098, 1142, 1211,
  993, 992, 1098, 1107, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992,
  992, 1269, 1269, 1269, 1269, 986, 992, 1269, 1269, 1269, 1269, 985, 992, 1268, 1269, 1269, 1269, 1269, 985, 1301,
  1112, 1314, 1108, 1107, 1113, 992, 992, 992, 992, 1225, 1326, 1392, 1268, 1336, 1008, 1301, 1175, 1346, 1109, 1107,
  1113, 992, 992, 992, 992, 1407, 1281, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 989, 992, 992, 992, 992, 992,
  992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 1264, 1369, 989, 992, 992, 992, 992, 1378, 991, 1378, 1198, 1389,
  1338, 1197, 1224, 992, 992, 992, 992, 1407, 992, 1328, 1406, 1291, 989, 992, 992, 992, 992, 1402, 991, 1404, 1269,
  1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 988, 1269,
  1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 990, 1052, 992, 992, 992, 1268, 1318, 1140, 992, 1268,
  1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 987, 1185, 1268, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269,
  1269, 1269, 1415, 1391, 1269, 1269, 1269, 1269, 987, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992,
  992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 1107, 1110, 1359, 992,
  992, 992, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269,
  1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 986, 992, 992, 992, 992, 992, 992,
  992, 992, 992, 992, 992, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269, 1269,
  1269, 1269, 1269, 1269, 1269, 988, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 992, 1113, 1107, 1113, 976, 1351,
  1269, 1268, 1269, 1269, 1269, 990, 1106, 1107, 1306, 1111, 1305, 1106, 1107, 1109, 1106, 1359, 992, 992, 992, 992,
  992, 992, 992, 992, 1268, 1269, 1269, 1269, 985, 1404, 1268, 1269, 1269, 1269, 985, 992, 1106, 1107, 1138, 1107, 1107,
  1074, 1356, 992, 1269, 1269, 1269, 989, 989, 992, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 2, 2,
  2, 2, 4, 5, 6, 7, 2, 2, 8, 9, 10, 9, 9, 11, 2, 2, 2, 2, 2, 9, 2, 9, 12, 13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 2, 2, 2,
  2, 2, 9, 9, 2, 13, 13, 13, 2, 14, 2, 2, 13, 13, 2, 13, 13, 2, 2, 13, 13, 13, 13, 13, 2, 2, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 13, 13, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 13, 2, 38, 2, 2, 2, 2, 2, 9, 2, 13, 13, 13,
  13, 13, 13, 2, 13, 13, 13, 13, 13, 2, 9, 9, 9, 9, 2, 9, 9, 9, 2, 9, 9, 9, 2, 2, 13, 13, 13, 13, 13, 2, 2, 13, 13, 13,
  2, 2, 13, 13, 2, 2, 2, 2, 9, 9, 2, 9, 9, 9, 9, 9, 9, 9, 9, 2, 2, 2, 2, 2, 2, 9, 13, 13, 13, 13, 13, 13, 13, 2, 13, 2,
  13, 13, 13, 13, 2, 13, 9, 9, 2, 9, 9, 9, 9, 9, 2, 2, 9, 9, 9, 9, 9, 9, 9, 13, 13, 9, 9, 2, 2, 9, 9, 9, 2, 2, 2, 2, 9,
  13, 13, 2, 2, 9, 13, 9, 9, 2, 9, 9, 13, 2, 2, 2, 2, 2, 9, 9, 2, 2, 9, 9, 2, 13, 13, 13, 13, 2, 13, 2, 2, 2, 13, 13, 2,
  2, 2, 13, 13, 2, 2, 9, 2, 9, 9, 9, 9, 2, 2, 2, 9, 9, 2, 2, 2, 2, 13, 13, 2, 13, 2, 2, 13, 2, 2, 9, 2, 2, 13, 13, 13,
  2, 13, 13, 2, 13, 13, 13, 13, 2, 13, 2, 13, 13, 9, 9, 13, 13, 13, 2, 2, 2, 2, 13, 13, 2, 13, 13, 2, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 2, 2, 2, 13, 13, 2, 2, 13, 2, 2, 13, 13, 2, 13, 2, 13, 13, 13, 13, 2, 2, 13, 9, 13, 13, 9,
  9, 9, 9, 9, 9, 2, 9, 9, 13, 13, 13, 13, 13, 13, 9, 9, 9, 9, 9, 9, 13, 2, 13, 2, 2, 13, 2, 2, 13, 13, 2, 13, 13, 13, 2,
  13, 2, 13, 2, 13, 13, 13, 13, 13, 13, 2, 9, 2, 2, 2, 2, 9, 9, 2, 9, 2, 2, 2, 2, 2, 2, 13, 9, 2, 13, 2, 13, 13, 2, 13,
  13, 2, 2, 2, 2, 2, 13, 2, 13, 2, 13, 2, 13, 2, 13, 2, 2, 2, 2, 2, 13, 13, 13, 13, 13, 13, 2, 2, 2, 13, 2, 2, 2, 2, 2,
  2, 2, 13, 2, 13, 13, 13, 2, 9, 9, 9, 2, 13, 13, 13
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 2, 2
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1025, 2049, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 2560, 2575, 3281, 3281, 3281, 2602, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2636, 2624, 3281, 3281, 3281,
  2602, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 2727, 2653, 3281, 3281, 3281, 2681, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2715, 2703, 3281, 3281, 3281, 2755, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2799, 2815, 3281,
  3281, 3281, 2843, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 2864, 2893, 3281, 3281, 3281, 2637, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2665, 2624, 3281, 3281, 3281, 2602, 2848, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2636,
  2921, 4367, 2958, 3656, 7039, 8454, 2957, 2957, 4213, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 8450, 2956,
  2957, 6205, 3656, 7917, 5324, 2957, 7653, 3658, 2951, 7290, 3656, 2946, 5225, 3657, 4129, 7768, 5471, 7414, 7684,
  8185, 2779, 7026, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 2636, 2921, 4367, 2958, 3656, 7039, 8454, 2957, 2957, 4213, 3656, 7915, 8137,
  2957, 2957, 2782, 3656, 3656, 8450, 2956, 2957, 6205, 3656, 7917, 2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803,
  5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2974, 2990, 3281, 3281, 3281, 2602,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3018, 3046, 2687, 3154, 3106, 3074, 2607, 3153, 3153, 3102, 3106, 3124, 2608, 3153, 3153, 3229, 3106, 3106,
  3280, 3152, 3153, 3210, 3106, 3126, 3151, 3153, 3106, 3108, 3147, 3177, 3106, 3142, 3177, 3107, 3149, 3209, 3170,
  3193, 3230, 3228, 3226, 3203, 3246, 3250, 3266, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2739, 2624, 3281, 3281, 3281, 2602, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2767, 2921, 4367, 2958,
  3656, 7039, 8136, 2957, 2957, 7737, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 8450, 2956, 2957, 6205, 3656,
  7917, 2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803, 5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244,
  3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 2636, 3297, 3281, 3281, 3281, 2602, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3030, 3325, 3337, 6105, 3353, 3383, 5867, 2957, 5731,
  7737, 3656, 3406, 5894, 6148, 2957, 3453, 3656, 7447, 4073, 3469, 3494, 4418, 7441, 7917, 2955, 7235, 3656, 4042,
  2951, 5225, 3656, 5803, 3513, 3554, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2767, 2921,
  4367, 2958, 3656, 7039, 8136, 2957, 2957, 7737, 3656, 7915, 6966, 2957, 3766, 2782, 3656, 3437, 8450, 2956, 2957,
  6205, 3656, 6829, 3591, 2957, 3613, 3658, 2951, 5225, 3656, 5803, 5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781,
  6403, 3633, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3058, 2921, 4367, 7708, 5103, 3367, 8337, 4396, 2957, 7109, 3655, 7938, 8137, 6855,
  7281, 2782, 3674, 3691, 8450, 2956, 2957, 6205, 3656, 7917, 2955, 2957, 3656, 3658, 7207, 4178, 4860, 7261, 6290,
  6821, 2953, 7153, 8233, 5603, 2783, 2781, 8315, 6244, 3534, 3538, 7573, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3086, 2921, 3710, 3737, 6571, 8329, 4657,
  2957, 3762, 7648, 6603, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 8450, 3782, 2957, 3804, 3656, 3829, 3853, 4140,
  3873, 7910, 3891, 6915, 8544, 5803, 5225, 3657, 2953, 7536, 8380, 5603, 2783, 3939, 2779, 6244, 3534, 3538, 4827,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3309, 3966, 3982, 4023, 4058, 7039, 2930, 6887, 3721, 4098, 3950, 4114, 4163, 4200, 4233, 4282, 4317, 4333, 4361,
  4383, 5557, 4434, 7542, 8444, 4450, 4478, 5953, 4518, 5405, 6072, 4555, 4345, 4583, 4642, 6652, 4886, 8045, 4698,
  4744, 3429, 4772, 4813, 3534, 4843, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 2877, 2921, 4367, 4876, 7072, 4785, 8136, 5418, 2957, 4247, 3656, 7915,
  8137, 2957, 7879, 2782, 3656, 5946, 8450, 2956, 2957, 6205, 3656, 7917, 4910, 3478, 3656, 5782, 2951, 5225, 3656,
  5803, 5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 4756, 7980, 4927, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 7588, 2921, 4367, 2958, 3656,
  7039, 8136, 2957, 2957, 7737, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 8450, 2956, 2957, 6205, 3656, 7917,
  2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803, 5225, 3675, 8631, 5757, 4007, 6234, 2783, 2781, 2779, 6244, 3534,
  3639, 4958, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 2767, 2921, 4539, 7335, 4989, 5007, 8136, 2957, 8176, 7737, 8701, 7915, 8137, 2957, 2957, 2782, 3656,
  3656, 8450, 2956, 2957, 6205, 3656, 7917, 2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803, 5225, 3657, 2953, 6204,
  8045, 5030, 2783, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 4942, 5064, 3575, 2958, 5100, 7039, 5119, 5166, 6485, 5133,
  5202, 4293, 4797, 2957, 7377, 5179, 3656, 8585, 8450, 5221, 2957, 4034, 3656, 7917, 2955, 2957, 3656, 4991, 5241,
  5268, 5299, 5315, 5340, 5364, 2953, 6204, 8045, 5603, 2783, 7857, 2779, 6244, 8301, 3538, 8417, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 4973, 5391, 7046,
  2958, 5439, 5856, 8136, 7968, 4626, 5461, 5487, 6685, 8137, 5503, 2957, 4184, 8194, 3656, 4266, 2956, 5923, 6205,
  3813, 5683, 5547, 2957, 5142, 3875, 3419, 5225, 5582, 5803, 5225, 3657, 2953, 5600, 5619, 5603, 2783, 2781, 2779,
  7475, 5642, 6080, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 6449, 5699, 3390, 5747, 5773, 7039, 8136, 8081, 5084, 4492, 3656, 5798, 8137, 8167, 5824,
  6248, 5843, 3656, 8450, 8239, 4147, 6468, 3694, 7917, 2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803, 5225, 3657,
  2953, 6204, 8045, 5603, 4462, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 8505, 5883, 5910, 5969, 6008, 7039, 8136, 2957,
  2957, 7737, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 5283, 6024, 4682, 4854, 7079, 6043, 6059, 6096, 6765,
  5676, 5808, 5225, 6812, 4567, 6327, 8036, 6121, 5348, 6137, 5982, 2783, 6170, 4710, 6198, 3534, 6221, 5531, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 8732,
  6264, 6312, 6378, 6419, 7039, 8136, 2957, 5252, 7737, 7158, 4258, 4082, 7176, 2957, 6465, 6578, 3617, 8450, 2956,
  6484, 6205, 6501, 7917, 2955, 2957, 3656, 3658, 5077, 5423, 3656, 5375, 5225, 6523, 2953, 6204, 4720, 6545, 3746,
  6561, 2779, 6244, 3534, 3538, 7618, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 2827, 2921, 4367, 2958, 3656, 7122, 8136, 5566, 6027, 7826, 6594, 6354, 8137,
  2957, 2957, 2782, 3656, 3656, 4531, 4911, 2957, 6205, 6619, 7917, 2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803,
  5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2767, 6638, 3923, 5827, 6675, 6701,
  8136, 2957, 2957, 7737, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 8450, 2956, 2957, 6205, 3656, 7917, 2955,
  2957, 3656, 3658, 2951, 5225, 3656, 5803, 5225, 3657, 5713, 6923, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538,
  4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 6724, 2921, 6279, 4407, 6507, 7039, 6740, 6659, 5043, 7737, 6781, 7915, 3837, 6862, 2957, 3906, 6792, 5205,
  8683, 2956, 6845, 3997, 8659, 3916, 6878, 2957, 6802, 3658, 2951, 8387, 3656, 6903, 5048, 3657, 2953, 6204, 8045,
  7354, 6995, 2781, 6342, 6244, 3534, 8286, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 6939, 6955, 6982, 7011, 7062, 8009, 7095, 7138, 2957, 5517, 5666,
  7915, 8137, 2957, 2957, 2782, 3656, 3656, 6362, 7174, 4728, 5936, 6622, 7192, 2955, 7227, 3656, 7251, 2951, 7306,
  8202, 5803, 5225, 3657, 7331, 7351, 7370, 5603, 7393, 2781, 7430, 7405, 7463, 3538, 4827, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 7491, 7507, 7523, 7558,
  7604, 7039, 7634, 7669, 7700, 6754, 6182, 6529, 7724, 7757, 7784, 6296, 8533, 5186, 4301, 2956, 6154, 6205, 3656,
  7800, 7842, 7873, 7895, 7933, 7954, 7996, 8025, 8067, 8101, 8117, 8153, 8218, 8255, 6391, 2783, 2781, 2779, 5992,
  8271, 3538, 6434, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 8353, 2921, 4367, 2958, 3656, 7039, 8136, 2957, 2957, 8369, 3656, 4894, 7813, 4618, 4672, 2782,
  8403, 8433, 8131, 7271, 2957, 7315, 3656, 7917, 2955, 2957, 3656, 3658, 4609, 8085, 3656, 5803, 5225, 3657, 2953,
  6204, 4502, 3524, 2783, 2781, 2779, 5654, 8470, 8474, 8490, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2905, 2921, 5014, 2958, 8521, 4596, 8136, 5725, 2957,
  8573, 3656, 7915, 8560, 3857, 2957, 2782, 5150, 3656, 8450, 2956, 2957, 6205, 3656, 7917, 2955, 2957, 3656, 3658,
  2951, 5225, 3656, 5803, 5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 8601, 2921,
  4367, 2958, 3656, 7039, 8136, 2957, 2957, 7737, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 8450, 2956, 2957,
  6205, 3656, 7917, 7211, 3788, 4217, 5445, 2951, 5225, 3656, 5803, 5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781,
  2779, 6244, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3002, 8617, 6708, 2958, 8647, 7039, 8136, 2957, 3597, 7737, 3656, 8675, 8137, 2957,
  2957, 2782, 3656, 3656, 8450, 2956, 2957, 6205, 3656, 7917, 2955, 2957, 3656, 3658, 2951, 5225, 3656, 5803, 5225,
  3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538, 4827, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 2767, 2921, 4367, 5626, 5584, 7039, 8136,
  2957, 2957, 7737, 3656, 7915, 8137, 2957, 2957, 2782, 3656, 3656, 3568, 8051, 2957, 6205, 8699, 7917, 2955, 3497,
  3656, 7741, 2951, 5225, 3656, 5803, 5225, 3657, 2953, 6204, 8045, 5603, 2783, 2781, 2779, 6244, 3534, 3538, 4827,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  8717, 2624, 3281, 3281, 3281, 2602, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 2586, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281,
  3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 3281, 4113, 4113, 4113, 4113, 20, 4113,
  4113, 4113, 4113, 4113, 4113, 0, 4113, 4113, 4113, 4113, 0, 0, 20, 20, 20, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 11264,
  11264, 11264, 11264, 11264, 0, 0, 0, 0, 11264, 0, 0, 0, 0, 20, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 110,
  110, 0, 0, 0, 20, 20, 20, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 20, 20,
  0, 3158, 25, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 10283, 10240, 10283, 10283, 10283, 0, 0, 0, 20, 20, 24, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 109, 110, 110, 110, 110, 110, 0, 0, 0, 20, 20, 20, 0, 24, 3159, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0,
  0, 0, 0, 25, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 19456, 19456, 19456, 0,
  0, 0, 20, 20, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5146, 6188, 6208, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6188, 18, 12306, 18, 18, 21, 18, 18,
  12306, 18, 12306, 18, 0, 18, 18, 18, 18, 0, 0, 0, 138324, 138324, 20, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0,
  0, 5146, 6200, 6220, 6200, 6200, 6200, 0, 0, 0, 138324, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8192, 0, 0, 0, 0,
  14336, 0, 20, 0, 0, 0, 0, 0, 14336, 0, 14336, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5151, 6193, 6213, 6193, 6193, 6193, 0, 0,
  0, 20, 20, 17408, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5146, 6205, 6225, 6205, 6205, 6205, 0, 0, 0, 20,
  20, 20, 0, 24, 25, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5321, 5146, 5323, 9420, 6349, 6188, 6188,
  6684, 6208, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 0, 0, 0, 0, 20, 0, 15383, 15383, 15383, 15383, 0, 0, 0, 0, 0,
  15383, 0, 0, 0, 20, 20, 20, 16384, 24, 25, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5146, 6207, 6227, 6207, 6207, 6207,
  0, 0, 0, 19, 22, 0, 0, 0, 19, 19, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5147, 6189, 6209, 6189, 6189, 6189, 0, 13312,
  18432, 138325, 13312, 138325, 0, 24, 25, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5148, 6190, 6210, 6190, 6190, 6190,
  148, 148, 148, 0, 138325, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5149, 6191, 6211, 6191, 6191, 6191, 110,
  110, 110, 0, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 0, 0, 148, 148, 148, 148,
  148, 148, 148, 148, 148, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148, 148, 148, 148, 0, 0, 0, 0, 0, 0, 0, 110, 110, 110, 110, 110,
  110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 148, 148, 148, 148, 148, 148, 148, 0, 110, 110, 110, 110, 110,
  110, 110, 110, 110, 110, 110, 110, 110, 148, 148, 148, 110, 110, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148,
  148, 110, 110, 110, 110, 110, 110, 110, 110, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 148, 110,
  110, 110, 110, 110, 110, 110, 110, 110, 148, 148, 148, 148, 148, 148, 148, 148, 148, 110, 148, 148, 148, 110, 110,
  110, 110, 110, 110, 148, 148, 148, 148, 148, 148, 110, 110, 110, 110, 148, 148, 148, 148, 110, 110, 148, 148, 110,
  148, 110, 148, 110, 148, 110, 148, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 20, 20, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5150, 6192, 6212, 6192, 6192, 6192, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146,
  5210, 5146, 5146, 5146, 5146, 5146, 5146, 5224, 5146, 5146, 5146, 0, 6188, 6188, 6258, 6188, 6188, 6208, 6296, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6315, 6208, 6318, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5306, 5146,
  5146, 5146, 5146, 5146, 5146, 5313, 6327, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 5146, 0, 6188, 6188, 6188, 6188, 6265, 6208, 6425, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5146,
  5413, 5146, 5146, 5146, 5146, 5146, 5146, 6188, 6188, 6188, 6655, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6794,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6512, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6478, 6188, 6188,
  6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6493, 5146, 6188, 6188, 6188, 6534, 6188,
  6535, 6188, 6537, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6617, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6546, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 89132,
  6697, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6706, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6762, 6208,
  6208, 6208, 6208, 6208, 6208, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6188, 6188,
  6188, 6188, 6208, 6208, 6208, 6714, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6723, 6208, 6208, 6208, 5146,
  5146, 5146, 5146, 5146, 42010, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 0, 6188, 6188, 6188, 6262,
  6188, 5146, 5146, 6188, 6188, 6601, 6602, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6384, 6188, 6188, 6188, 6208, 6208, 6624, 6625, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6515, 6208, 6208, 6208, 6208, 6818, 6208, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208,
  6208, 6208, 6208, 6188, 48172, 71724, 6188, 6208, 6407, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 6494, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 23578, 6208, 6507, 6508, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6585, 6208, 5218, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 0, 6188, 6188, 6188,
  6188, 6188, 6376, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6385, 6188, 6188, 6188, 6188, 6269, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6779, 6208, 6208, 6208, 6208, 6208, 6208, 6188,
  6188, 62692, 6373, 6374, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6477,
  6188, 5146, 6188, 6188, 6188, 6188, 28716, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6619, 6188, 6188, 6188, 6558, 6559, 6188, 6188, 6208, 6208, 6208, 6208, 28736, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6578, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6586, 6208, 6208, 6208, 6588, 6589, 6208, 6208, 5567, 5146,
  5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5425, 9420, 6349, 6188, 6188, 6452, 5146, 5146, 6188, 6600,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 52268, 6188, 6208, 6623, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5622, 5146, 5146, 5624, 5146,
  5146, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6657, 6188, 6188, 6188, 6481, 6188, 6483, 6188, 6208,
  6208, 6487, 6208, 6208, 6208, 6208, 6208, 6208, 6590, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 0,
  6188, 6188, 6188, 6188, 44076, 6188, 6788, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6797, 6208, 6208, 6208,
  6208, 6208, 6413, 6208, 6208, 6208, 6208, 6208, 6418, 6208, 6208, 6208, 6208, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146,
  5146, 5146, 5212, 5146, 5146, 50202, 5146, 59492, 5146, 64538, 5146, 5223, 5146, 5146, 5146, 5146, 0, 6188, 6188,
  6188, 6261, 6188, 6188, 6188, 6560, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 35866,
  6188, 6188, 35884, 6188, 6188, 6188, 6188, 6756, 6188, 6188, 50220, 6188, 59521, 6188, 64556, 6188, 6188, 6279, 6282,
  6285, 6188, 6188, 6188, 6188, 6208, 6208, 6563, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6641, 6208,
  6208, 6208, 6644, 6208, 5146, 5146, 6208, 6208, 6299, 6208, 6208, 50240, 6208, 59559, 6208, 64576, 6208, 6208, 6317,
  6320, 6323, 6208, 5146, 5497, 5498, 5146, 5146, 5146, 5146, 5502, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 5424, 5146, 9420, 6349, 6188, 6188, 6188, 6188, 6390, 6188, 6349, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6403, 6208, 6406, 6208, 6208, 6208, 6427, 6208, 6208, 6208, 6432, 6208, 5410, 25626, 5146, 5146, 5146,
  40986, 5146, 5146, 5146, 5146, 6728, 6188, 6188, 6188, 6188, 6188, 6731, 6188, 6188, 6188, 6188, 6188, 6188, 6615,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6555, 6188, 6188, 6188, 6188, 5416, 5146, 5146,
  5418, 5419, 5146, 5146, 5146, 5146, 5146, 5146, 9420, 6349, 6450, 6451, 6188, 6188, 6188, 6661, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6489, 6490, 6208, 6492, 6208, 25644, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 41004, 6188, 6188, 6464, 6188, 6188, 6188, 0, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6634, 6208, 6208, 6188, 6468, 6188, 6188, 65580, 6470, 6471, 6188, 6188, 6188,
  6188, 6476, 6188, 78892, 6188, 6188, 6188, 6349, 6208, 6208, 6208, 6208, 6208, 6208, 6400, 6208, 6208, 6208, 6208,
  6208, 6430, 6208, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5506, 5146,
  5146, 6188, 6479, 6188, 6188, 6188, 6188, 6484, 6485, 6486, 6208, 25664, 6208, 6208, 6208, 6208, 6208, 6429, 6208,
  6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 82970, 5146, 6208, 6208,
  6208, 41024, 6208, 6208, 6499, 6208, 6208, 6208, 6208, 6503, 6208, 6208, 65600, 6505, 6506, 6208, 6208, 6208, 6208,
  6511, 6208, 78912, 6208, 6208, 6208, 6514, 6208, 6208, 6208, 6208, 5146, 27674, 5146, 5146, 55322, 5146, 5668, 6188,
  6188, 6188, 27692, 6188, 6519, 5146, 5146, 5146, 5146, 5500, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 0, 6188, 6188, 6188, 6188, 6188, 88090, 6188, 6188, 6188, 6188, 6188, 6188, 6536, 6188, 6188, 6539, 6188, 6541,
  6188, 6188, 6188, 6188, 6357, 6188, 6360, 6188, 6188, 6188, 6365, 6188, 6188, 6188, 6188, 6188, 6188, 66692, 6278,
  6188, 6188, 6286, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6564, 6208, 6565, 6208, 6567, 6208, 6208, 6208, 6208,
  6188, 6188, 88108, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6566, 6208, 6208, 6569, 6208, 6571, 5146, 79898, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6608, 6188, 6188, 6188, 6188, 6188, 6776, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6785, 6188, 6188, 6188, 6188, 63532, 6614, 6188, 6188, 6188, 6188, 6188, 6188, 79916, 6188,
  6620, 6188, 6188, 6188, 6349, 6208, 6208, 6208, 6208, 6208, 6398, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 6188,
  6188, 6188, 6188, 6753, 6188, 6188, 6188, 6188, 6208, 63552, 6637, 6208, 6208, 6208, 6208, 6208, 6208, 79936, 6208,
  6643, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5501, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5228, 0, 6188, 6188, 6259, 6188, 6188, 6208, 6208, 6208, 31808, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6680, 6208,
  6208, 6208, 6208, 5664, 5146, 5146, 5146, 5146, 5146, 5146, 6188, 6694, 6188, 6188, 6188, 6188, 6188, 6700, 6188,
  55340, 6188, 6188, 6188, 6705, 6707, 6188, 6709, 87084, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5146, 5146,
  36890, 5146, 5146, 5146, 5146, 5146, 5146, 6188, 6188, 6654, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6460, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6381, 6188, 6188, 6188, 6188, 6188, 6188, 27712, 6208, 6208, 6208,
  6717, 6208, 55360, 6208, 6208, 6208, 6722, 6724, 6208, 6726, 87104, 5146, 5146, 5146, 5146, 62490, 5317, 5146, 5146,
  5146, 5146, 5146, 5146, 9420, 6349, 22572, 6188, 6188, 6188, 6469, 6188, 6188, 6188, 6188, 6188, 6474, 6188, 6188,
  6188, 6188, 6188, 6188, 6550, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 85036, 6758, 6188, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6767, 6208, 6188, 6188, 6188, 6188, 6188, 6188, 6809, 6188, 6811, 6208, 6208,
  6208, 6208, 6208, 6208, 5146, 6750, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6554, 6188, 6188,
  6188, 6557, 6188, 6771, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6780, 6208, 6208, 6208, 6208, 6208, 6188,
  6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 21548, 6803, 6188, 6188, 38956, 6188, 6188, 6188,
  6188, 6188, 6188, 6208, 6208, 38976, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5146, 5309, 5146, 5146, 5146,
  5146, 5146, 5146, 5421, 5146, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 6188, 6208, 6208, 6208, 6820, 6188, 43052,
  6188, 6188, 6188, 6188, 6188, 6826, 6208, 43072, 6208, 6208, 6208, 6188, 6188, 6208, 6208, 6188, 6208, 6188, 6208,
  6188, 6208, 6188, 6208, 0, 6844, 6188, 6188, 6188, 75820, 6208, 6848, 6208, 6208, 6208, 75840, 6188, 6188, 6188, 6188,
  6208, 6562, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6679, 6208, 6208, 6208, 6208, 6208, 6188,
  6188, 53292, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 24640, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6433, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5574, 5146, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6543, 6208, 6208, 6208, 34860, 6188, 34880, 6208,
  6188, 6208, 6188, 6208, 6188, 6208, 6188, 6208, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5153, 6195, 6215, 6195, 6195, 6195,
  48192, 71744, 6208, 6188, 6188, 6208, 6208, 6188, 6208, 6188, 6208, 6188, 6208, 6188, 6208, 0, 0, 0, 0, 20, 0, 0, 0,
  0, 0, 5154, 6196, 6216, 6196, 6196, 6196, 6208, 6297, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 5621, 5146, 6208, 6328, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 5146, 0, 6188, 6188, 6188, 6188, 6266, 6188, 84012, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  84032, 6188, 6188, 6188, 6188, 6375, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  21046, 6208, 6208, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5146, 5213, 5146, 5146, 5146, 5146, 5146, 5146, 6652,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6382, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6300,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6319, 6208, 6208, 5146, 5314, 5146,
  5146, 5146, 5146, 5146, 5146, 5146, 5146, 5322, 5146, 9420, 6349, 6188, 6188, 6188, 6349, 6208, 6208, 6208, 6208,
  6396, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6629, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 52288, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6188, 6188, 6354, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6367,
  6188, 6188, 6188, 6188, 6482, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 80960, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6409, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6516, 6208, 6518, 5146, 6188, 6188, 6533, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6208, 6208, 6208, 5623, 5146, 5146, 5146, 5146, 5627, 6188, 6653, 6188, 6188, 6656, 6188, 6188, 6188,
  6188, 6188, 6377, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6388, 6188, 6188, 6660, 6188, 6188, 6188,
  6663, 6188, 6665, 6188, 6667, 6188, 6188, 6208, 6671, 6208, 5496, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 5146, 5146, 5146, 5146, 85018, 6208, 6674, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6678, 6208, 6208, 6208,
  6681, 6208, 6683, 6208, 6685, 6208, 6208, 5146, 5146, 5146, 5666, 5146, 5146, 5146, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6610, 6188, 6188, 6698, 6188, 6188, 6188, 6188, 6188, 6188, 6704, 6188, 6188,
  6188, 6188, 6188, 6208, 6208, 6208, 29760, 6740, 6741, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6715, 6208, 6208,
  6208, 6208, 6208, 6208, 6721, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5665, 5146, 5146, 5146, 5146, 6188, 6188,
  6188, 6188, 6696, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5146, 5146, 5214, 5146, 5146, 5146, 5146, 5626, 5146,
  6188, 6188, 6188, 6188, 6188, 6188, 31788, 6188, 6188, 6188, 6188, 6358, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6670, 6208, 6208, 6208, 6208, 6208, 6302, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6642, 6208, 6208, 6208, 5146, 5146, 6389, 6188, 6188, 6349, 6208, 6208, 6208,
  6208, 6208, 6397, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 6188, 6188, 6188, 6188, 6188, 6754, 6755, 6188, 6188,
  6208, 6408, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6423, 6188, 6454, 6455,
  6188, 6457, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6465, 6188, 6188, 6188, 6349, 6208, 6208, 6208, 6395,
  6208, 6208, 6401, 6208, 6208, 6404, 6208, 6208, 6208, 6188, 6188, 6208, 6208, 6188, 6208, 6188, 6208, 6188, 6208,
  72748, 72768, 0, 5146, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6606, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6551, 6552, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6363, 6188, 6188, 6188, 6188, 6368, 6188, 6188, 6673,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6325, 6208, 6188, 6188,
  6737, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6188, 6188, 6188, 6208, 6208,
  6208, 6748, 6208, 6208, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6287, 6188, 6188, 6188,
  6188, 6208, 6208, 6208, 6208, 6832, 6188, 6188, 6188, 6188, 6188, 6838, 6208, 6208, 6208, 6208, 6208, 6188, 6188,
  6188, 6188, 6188, 6188, 6825, 6188, 6208, 6208, 6208, 6208, 6208, 6411, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 73792, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5146, 5570, 5146, 5146, 5146,
  5146, 5146, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5146, 5146, 5215, 5146, 5146, 5146, 5146, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6732, 6188, 6188, 6188, 6188, 6188, 36908, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6383, 6188, 6188, 6188, 6188, 6188, 6188, 6270, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6208, 23616, 6208, 6208, 6208, 6208, 6208, 6208, 47704, 6208, 71257, 6208, 6208, 6208, 6303,
  6208, 6208, 6308, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6640, 6208, 6208, 6208, 6208, 6208, 6208,
  5146, 5146, 6424, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6658, 6188, 6188, 58412, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6291, 6208, 6208, 6208, 6496, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 58432, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5308, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 5320, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5208, 5146, 5146, 5146,
  5146, 5146, 5146, 5146, 5146, 5423, 5146, 5146, 9420, 6349, 6188, 6188, 6188, 5219, 5146, 5146, 5146, 5146, 5146,
  5146, 5146, 5227, 5146, 0, 6188, 6255, 6188, 6188, 6188, 6188, 6548, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6556,
  6188, 6188, 6188, 6188, 6561, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 77888, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6631, 6208, 6208, 6208, 6208, 6208, 6208, 6188, 6188, 6271, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6288, 6188, 6188, 6188, 6208, 6208, 6208, 6761, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 76844, 6208, 6208, 6208, 6208, 6208, 6293, 6208, 6208, 6208,
  6208, 6208, 6309, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6326, 5146, 6188, 6532, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6386, 6188, 6208, 6208, 85056, 6208, 6208, 6208, 6208,
  5146, 5146, 5146, 5146, 5571, 5146, 5572, 5146, 73754, 5146, 5146, 6188, 6188, 6188, 6188, 6188, 6604, 6188, 6188,
  6607, 6188, 6609, 6188, 6188, 6188, 6188, 6662, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208,
  6208, 6208, 6208, 6852, 6188, 6188, 6188, 6854, 6188, 6612, 6188, 6188, 6188, 6188, 6188, 6188, 73772, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6277, 6188, 6280, 6188, 6188, 6289, 6188, 6188, 6208, 29722, 5703, 5146, 5146, 6188,
  6188, 6188, 29740, 6729, 6730, 6188, 6188, 6188, 6188, 6188, 6735, 6746, 6208, 6208, 6208, 6208, 6208, 5146, 6188,
  6188, 6188, 6752, 6188, 6188, 6188, 6188, 6188, 6458, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 82988, 6188, 6188, 6188, 6188, 6789, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6798, 6208,
  6208, 6208, 6208, 6412, 6208, 60480, 6208, 6208, 6208, 6208, 6208, 6420, 6421, 6208, 6208, 6817, 6208, 6819, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6188, 6845, 6846, 6188, 6188, 6208, 6208, 6849, 6850, 6208, 6208, 6188, 6188, 6188, 6188, 6208, 6208, 35904, 6208,
  6208, 6208, 6208, 6765, 6208, 6208, 6208, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208,
  6208, 6208, 6491, 6208, 6208, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5211, 5146, 5146, 5217, 5146, 5146, 5146,
  5146, 66662, 5146, 5146, 5226, 5146, 5146, 0, 6188, 6188, 6188, 6188, 6188, 6702, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6208, 6208, 6208, 26968, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5221, 5146, 5146, 5146, 5146, 81946, 5146,
  5146, 0, 6188, 6188, 6260, 6263, 6188, 6188, 6188, 6701, 6188, 6188, 6703, 6188, 6188, 6188, 6188, 6188, 6188, 6208,
  6711, 6208, 6188, 6805, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6813, 6208, 6208, 6208, 6208, 6428, 6208,
  6208, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5505, 5146, 5146, 5146, 6268,
  6188, 6188, 6188, 6274, 6275, 6188, 6188, 6188, 6283, 81964, 6188, 6188, 6188, 6188, 6208, 34408, 6208, 6208, 6208,
  6208, 6208, 6208, 6766, 6208, 6208, 6188, 6188, 6188, 6188, 6807, 6808, 6188, 6810, 6188, 6208, 6208, 6208, 6208,
  6815, 6816, 6208, 6298, 6301, 6208, 6306, 6208, 6208, 6208, 6312, 6313, 6208, 6208, 6208, 6321, 81984, 6208, 6208,
  6208, 6188, 6188, 6208, 6208, 6858, 6859, 6188, 6208, 6188, 6208, 6188, 6208, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5155,
  6197, 6217, 6197, 6197, 6197, 6188, 6188, 6480, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6570, 6208, 6544, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6387, 6208, 6208, 6208, 6574, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  66730, 6316, 6208, 6208, 6324, 6208, 6208, 6713, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 5146, 26915, 5146, 5146, 5146, 5146, 5415, 6188, 6188, 6759, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6188, 6188, 6770, 6787, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6796, 6208, 6208, 6208,
  6208, 6208, 6208, 6307, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6501, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6410, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 62734, 6415,
  6416, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6573, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6584, 6208, 6208, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5146, 5146, 44058, 5146, 5146,
  5146, 5146, 6188, 6188, 24620, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 49196, 6188, 6188,
  6188, 6188, 6208, 6208, 6208, 44096, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6431,
  6208, 6208, 5146, 5146, 5412, 5146, 5146, 5146, 5146, 6208, 6208, 6329, 20, 20, 0, 0, 5146, 5146, 5146, 5146, 5146,
  5146, 5146, 5146, 5146, 5146, 0, 6188, 6188, 6188, 6188, 6267, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5158, 6201, 6221, 6201,
  6201, 6201, 49178, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 6188,
  6349, 6208, 6208, 6394, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6627, 6208, 6208, 6630, 6208, 6632,
  6208, 6208, 6208, 6208, 6635, 6208, 49216, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6417, 6208, 6208, 6208,
  6208, 6208, 6498, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6628, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6676, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6719, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 5146, 5568, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 6188, 6545, 6188, 6547, 6188, 67989, 6188,
  6188, 6188, 6553, 6188, 6188, 6188, 6188, 6188, 6188, 6459, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6463, 6188, 6188, 6188, 6188, 5146, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6605, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6361, 6188, 6364, 6188, 6188, 6188, 6188, 6188, 6371, 6208, 6208, 6686, 6208, 5146, 5146,
  5146, 5146, 5146, 5146, 5146, 21029, 6188, 6188, 6188, 6188, 6188, 68652, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6743, 6208, 6208, 6208, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5159, 6202, 6222,
  6202, 6202, 6202, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5209, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5422, 5146,
  5146, 5146, 9420, 6349, 6188, 6188, 6188, 57370, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 0, 6188, 6256,
  6188, 6188, 6188, 6188, 6775, 6188, 6777, 6208, 6208, 6208, 6208, 6208, 6208, 6784, 6208, 6188, 6188, 6188, 57388,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6188, 6821, 6188, 6188,
  6188, 6188, 6188, 6188, 6208, 6827, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  5146, 5146, 0, 6188, 6188, 6188, 6188, 6264, 6294, 6208, 6208, 6208, 6208, 6208, 57408, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 53312, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6580, 6208, 6208, 6208, 6208,
  6208, 6208, 5146, 5146, 5315, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 6188,
  6349, 6392, 6393, 6208, 6208, 6208, 6208, 6399, 6208, 6402, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5146, 5146,
  5146, 5146, 5146, 5312, 5146, 6188, 6353, 6188, 6188, 6359, 6188, 6188, 6362, 6188, 6188, 6188, 6188, 6188, 6188,
  6369, 6188, 6188, 6188, 6738, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6419, 6208,
  6208, 6208, 6208, 5146, 6531, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6466, 6208, 6587, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5573, 5146, 5146,
  5146, 5625, 5146, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6611, 6188,
  6188, 6613, 6188, 6188, 6188, 6188, 6616, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6618, 6188,
  6188, 6188, 6621, 6188, 6636, 6208, 6208, 6208, 6208, 6639, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 5146,
  5146, 5146, 5146, 5146, 5667, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6538, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6472, 6473, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6666, 6188, 6188, 6188, 6208,
  6208, 6208, 6188, 6659, 6188, 6188, 6188, 6188, 6188, 6664, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6568, 6208, 6208, 6208, 5146, 5146, 5146, 74778, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6290, 6188, 6208, 74796, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6768, 6188, 6188, 6208, 74816, 6208, 6208, 6208, 6208, 5146, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6475, 6188, 6188, 6188, 6188, 6188, 6188, 6772, 6773, 6188, 6188, 6188,
  6208, 6208, 6208, 6208, 6781, 6782, 6208, 6208, 6208, 6188, 6188, 6188, 6188, 6188, 6824, 6188, 6188, 6208, 6208,
  6208, 6208, 6208, 6763, 6764, 6208, 6208, 6208, 6208, 6188, 6769, 6188, 6208, 6804, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6812, 6208, 6208, 6208, 6208, 6208, 6576, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6513, 6208, 6208, 6208, 6208, 6208, 6830, 6208, 6208, 6188, 6833, 6188, 6188, 6188, 6188, 6208, 6839, 6208,
  6208, 6208, 6208, 6188, 6188, 6188, 6822, 6823, 6188, 6188, 6188, 6208, 6208, 6208, 6828, 6829, 0, 0, 0, 0, 20, 0, 0,
  0, 0, 0, 5160, 6203, 6223, 6203, 6203, 6203, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5146, 5146, 5146, 5146,
  51226, 5146, 61466, 5146, 5146, 5146, 5146, 5225, 5146, 5146, 5146, 0, 6188, 6257, 6188, 6188, 6188, 6188, 86060,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6581, 6582, 6208, 6208, 6208, 6208, 6188, 51244,
  6272, 61484, 6188, 6188, 6188, 6188, 6188, 6284, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6188, 6856, 6208,
  6857, 6188, 6208, 6188, 6208, 6188, 6208, 6188, 6208, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5152, 6194, 6214, 6194, 6194,
  6194, 6295, 6208, 6208, 6208, 6208, 51264, 6310, 61504, 6208, 6208, 6208, 6208, 6208, 6322, 6208, 6208, 6208, 6188,
  6188, 6208, 6208, 6188, 6208, 6188, 6208, 6862, 6863, 6188, 6208, 0, 5146, 5146, 5316, 60442, 5146, 5146, 5318, 5319,
  5146, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 6188, 6349, 22592, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6633, 6208, 6208, 6208, 6208, 6352, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6370, 6188, 6188, 6188, 6774, 6188, 6188, 6208, 6778, 6208, 6208, 6208, 6208, 6783, 6208, 6208,
  6786, 60460, 6188, 6188, 6188, 6188, 6188, 6378, 6379, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6281,
  6188, 6188, 6188, 6188, 6188, 6208, 5146, 5146, 5417, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 9420, 6349,
  6188, 6188, 6188, 6349, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 89152, 5146,
  5146, 26933, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6462, 6188, 6188, 6188, 6188, 6188, 6739, 6208,
  6208, 6208, 6208, 6208, 6742, 6208, 6208, 6208, 6208, 6467, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 80940, 83008, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5569, 5146, 5146, 46106,
  5146, 5146, 5146, 5146, 5146, 5420, 5146, 5146, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 6188, 6349, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6405, 6208, 5146, 5146, 6599, 6188, 6188, 6188, 6603, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 46124, 6188, 6188, 6188, 6790, 6791, 6792, 6793, 6188, 6208, 6208, 6208, 6208, 6799,
  6800, 6801, 6802, 54316, 6188, 6188, 6188, 6188, 69676, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 77868, 6188, 6188, 6188, 6622, 6208, 6208, 6208, 6626, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 46144,
  6208, 54336, 6208, 6208, 6208, 6208, 6638, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5146,
  5146, 5146, 5146, 5146, 5146, 5146, 6208, 6208, 6208, 69696, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 5146, 5146, 5146, 5146, 5414, 5146, 5146, 5146, 32794, 5146, 5146, 5146, 5146, 6188, 6188, 6188, 6188, 6188,
  30764, 6188, 32812, 6188, 6188, 6188, 6355, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6366, 6188, 6188, 6188, 6188,
  6188, 21568, 6208, 6208, 6208, 6208, 6208, 6188, 6188, 6188, 6188, 6208, 39980, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6669, 6208, 6208, 6208, 20, 20, 0, 0, 5146, 5146, 5307, 5146, 5310, 5146, 5311, 5146,
  5146, 6208, 6208, 30784, 6208, 32832, 6208, 6208, 40000, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6718, 6208,
  6208, 6720, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 42382, 45100, 6188, 6208, 6208, 6208, 6687, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 6188, 6188, 6695,
  6188, 6188, 6188, 6356, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208,
  6672, 6188, 38443, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6708, 6188, 6188, 6208, 6208, 6712, 6208, 6208,
  6208, 38460, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6725, 6208, 6208, 5146, 5146, 5146, 5499, 5146, 5146,
  5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 9420, 6349, 6188, 6188, 6188, 5146, 5146, 56346, 5146,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 56364, 6188, 6188, 6188, 6456, 6188, 6188, 6188, 6188, 6461,
  6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6380, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6795, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6500, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6677, 6208, 6208, 6208,
  6208, 6208, 6682, 6208, 6188, 6736, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 56384,
  6208, 6208, 6208, 6208, 6749, 6208, 5146, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6188, 6540, 6188,
  6188, 6188, 6188, 6208, 6208, 6747, 6208, 6208, 6208, 5146, 6188, 34399, 6188, 6188, 6188, 6188, 6188, 6188, 6757,
  6208, 6208, 76864, 6188, 6188, 6188, 6188, 6836, 6837, 6208, 6208, 6208, 6208, 6842, 6843, 6188, 6188, 6188, 6847,
  6188, 6208, 6208, 6208, 6208, 6851, 6208, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6188, 6188, 6834, 6835, 6188,
  6188, 6208, 6208, 6840, 6841, 6208, 6208, 6188, 6188, 6188, 6806, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208,
  6814, 6208, 6208, 6208, 20, 20, 0, 0, 22554, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  9420, 6349, 6350, 6351, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5161, 6204, 6224, 6204, 6204, 6204, 6188, 6188, 6391, 6349,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 86080, 5146, 6188, 6188, 6188, 6188, 6188,
  6188, 6188, 6188, 6188, 6188, 6188, 6668, 6188, 6208, 6208, 6208, 6208, 6495, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6504, 6208, 6208, 6208, 6188, 6188, 6208, 6208, 6188, 6208, 6860, 6861, 6188, 6208,
  6188, 6208, 0, 6208, 6208, 6208, 6509, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 88128,
  6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 0, 0, 6188, 6188,
  6208, 6831, 6208, 6188, 6188, 6188, 6188, 6188, 6188, 6208, 6208, 6208, 6208, 6208, 6208, 6188, 6188, 6188, 6853,
  6208, 6208, 6208, 6855, 6188, 6188, 6208, 6208, 6188, 6208, 6188, 6208, 6188, 6208, 6188, 6208, 0, 0, 0, 0, 20, 0, 0,
  0, 0, 0, 5156, 6198, 6218, 6198, 6198, 6198, 6208, 6208, 6208, 6304, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6497, 6208, 6208, 6208, 6208, 6208, 6502, 6208, 6208, 6208, 6208, 6208, 6675, 6208, 6208,
  6208, 6208, 6208, 6208, 68672, 6208, 6208, 6208, 5146, 52250, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146,
  9420, 6349, 6188, 6188, 6188, 6349, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 36928, 6208, 6208, 6208, 6208, 6510,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6517, 6208, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 5162, 6206, 6226,
  6206, 6206, 6206, 0, 0, 0, 20, 20, 20, 0, 24, 25, 5146, 5146, 5146, 5146, 5216, 5146, 5146, 5146, 5146, 6188, 23596,
  6188, 6188, 6188, 6188, 6188, 6188, 47693, 6188, 71246, 6188, 6208, 6208, 6208, 6305, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6208, 6208, 6208, 6208, 6208, 6575, 6208, 6577, 6208, 68019, 6208, 6208, 6208, 6583, 6208, 6208, 6208,
  6208, 6208, 6426, 6208, 6208, 6208, 6208, 6208, 6208, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5146, 5503, 67610,
  5504, 5146, 5146, 5146, 5146, 42412, 45120, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208, 6208,
  6208, 6208, 6422, 6208, 0, 0, 0, 0, 20, 90112, 90112, 90112, 90112, 90112, 0, 0, 0, 0, 90112, 0, 0, 0, 0, 20, 0, 0, 0,
  0, 0, 5157, 6199, 6219, 6199, 6199, 6199
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  270, 274, 278, 282, 285, 291, 337, 302, 295, 297, 323, 306, 285, 287, 311, 337, 337, 337, 373, 320, 297, 297, 297,
  327, 285, 330, 334, 337, 337, 337, 338, 393, 297, 297, 297, 297, 343, 285, 348, 336, 337, 337, 314, 352, 297, 297,
  398, 344, 362, 336, 337, 337, 316, 297, 297, 406, 307, 364, 337, 339, 368, 297, 407, 377, 337, 339, 381, 398, 386,
  337, 390, 397, 382, 337, 404, 299, 402, 298, 337, 405, 301, 404, 300, 412, 300, 413, 411, 371, 355, 358, 487, 417,
  487, 421, 425, 480, 484, 487, 482, 486, 487, 431, 435, 487, 441, 446, 451, 487, 487, 442, 447, 487, 487, 669, 458,
  487, 598, 465, 470, 487, 487, 597, 464, 469, 487, 487, 680, 459, 487, 474, 478, 487, 487, 696, 493, 487, 487, 504,
  487, 511, 495, 487, 597, 512, 496, 487, 516, 598, 522, 487, 507, 530, 518, 531, 529, 487, 528, 487, 535, 539, 487,
  548, 437, 555, 589, 557, 563, 556, 562, 568, 561, 567, 583, 583, 542, 543, 544, 572, 586, 487, 576, 580, 487, 487,
  593, 487, 686, 690, 487, 688, 459, 487, 551, 596, 487, 487, 602, 607, 459, 487, 452, 603, 608, 487, 612, 617, 487,
  487, 454, 626, 631, 487, 487, 453, 625, 630, 487, 613, 487, 487, 454, 654, 517, 487, 460, 637, 631, 524, 487, 487,
  635, 641, 487, 487, 636, 642, 646, 487, 651, 674, 487, 663, 657, 667, 427, 674, 488, 673, 647, 489, 678, 659, 684,
  701, 497, 694, 500, 621, 499, 620, 498, 619, 700, 700, 705, 706, 707, 711, 715, 717, 720, 722, 724, 726, 728, 730,
  732, 734, 736, 959, 758, 826, 750, 760, 784, 751, 751, 751, 751, 845, 792, 751, 845, 762, 764, 773, 775, 847, 847,
  847, 847, 771, 857, 857, 857, 846, 781, 783, 751, 751, 777, 794, 790, 764, 857, 857, 766, 768, 802, 804, 812, 775,
  847, 847, 848, 960, 779, 806, 782, 784, 751, 752, 776, 787, 795, 817, 814, 857, 857, 857, 857, 765, 767, 806, 808,
  784, 751, 751, 810, 787, 789, 817, 801, 803, 805, 847, 856, 846, 856, 856, 856, 962, 751, 777, 788, 817, 814, 857,
  769, 803, 805, 847, 856, 857, 846, 797, 799, 751, 810, 787, 816, 769, 847, 847, 847, 785, 809, 751, 786, 819, 857,
  857, 858, 767, 800, 802, 804, 770, 847, 847, 847, 806, 857, 857, 857, 859, 847, 847, 847, 807, 809, 857, 857, 858,
  847, 847, 771, 956, 821, 821, 822, 740, 967, 825, 829, 831, 833, 740, 740, 747, 885, 740, 745, 851, 838, 941, 911,
  740, 740, 749, 743, 740, 963, 746, 877, 837, 837, 841, 879, 910, 871, 871, 740, 740, 740, 754, 746, 850, 842, 955,
  740, 740, 740, 755, 747, 835, 837, 863, 947, 947, 909, 915, 740, 740, 963, 747, 836, 862, 947, 914, 740, 740, 823,
  840, 868, 870, 873, 740, 740, 740, 740, 747, 852, 837, 895, 954, 890, 740, 740, 740, 848, 853, 740, 740, 740, 892,
  954, 740, 740, 964, 898, 963, 747, 861, 895, 954, 749, 954, 740, 740, 740, 906, 894, 954, 740, 740, 834, 938, 963,
  965, 904, 955, 740, 740, 963, 908, 740, 740, 743, 961, 894, 955, 740, 741, 739, 740, 741, 739, 744, 860, 913, 740,
  741, 851, 939, 961, 899, 740, 740, 741, 860, 741, 860, 739, 740, 740, 917, 740, 917, 899, 740, 740, 740, 919, 740,
  919, 740, 874, 875, 875, 921, 922, 924, 740, 741, 899, 740, 742, 742, 740, 744, 860, 739, 740, 926, 928, 842, 740,
  740, 740, 963, 747, 754, 756, 851, 886, 737, 737, 900, 934, 947, 955, 740, 936, 938, 940, 843, 843, 740, 740, 740,
  855, 898, 854, 740, 850, 885, 837, 738, 901, 901, 864, 947, 955, 740, 740, 745, 747, 851, 943, 901, 943, 945, 949,
  740, 740, 740, 844, 740, 740, 740, 740, 749, 747, 885, 939, 970, 946, 740, 740, 740, 866, 951, 740, 827, 951, 958,
  753, 740, 740, 740, 881, 952, 885, 945, 896, 740, 740, 969, 865, 740, 740, 884, 953, 853, 945, 740, 740, 930, 882,
  932, 947, 955, 740, 853, 902, 740, 740, 964, 888, 854, 740, 855, 898, 969, 854, 740, 848, 966, 740, 848, 966, 855,
  748, 855, 748, 748, 849, 849, 748, 4104, 6152, 12296, 135176, 69696, 5128, 54280, 56328, 185352, 187400, -1755303908,
  -523360, -511448, -257112, -256088, -207960, 8, 4096, 8192, 16384, 0, 0, 2, 0, 3, 4, 8, 48, 64, 0, 4, 16, 16, 256, 0,
  6, 8, 112, 4160, 65600, 6291472, 385875984, 16253088, 1056964768, -1073741664, 160, 1572896, 4194336, 8388640,
  67108896, 268435488, 32, 1048736, 16252960, 1056964640, -1073741792, 32, 1573024, 4194464, 4, 2097168, 4194320,
  117440528, 268435472, -2147483632, 16, 1048736, 4194464, 8388768, 67109024, 134217888, 805306528, 3670176, 4194464,
  8388768, 117440672, 134217888, 3670048, 4194336, 8388640, 117440544, 134217760, 268435488, 536870944, 1073741856,
  -2147483616, 32, 4194320, 67108880, 268435472, 16, 1573024, 134217760, 805306400, 1073741984, -2147483488, 67109024,
  268435616, 536871072, 8388768, 268435616, -1, -1, 0, 63, 5504, 32768, 4, 48, 196608, 14942208, 234881024, 268435456,
  1073741824, 0, 128, 768, 2048, 4096, 32768, 8128, 57344, 262144, 2097152, 0, 256, 160, 32, 32, 64, 64, 128, 256, 512,
  1024, 0, 32, 160, 160, 1048608, 32, 512, 4096, 24576, 262144, 524288, 0, 48, 196608, 33292288, 234881024, 805306368,
  -2147483648, -1073741824, 0, 8388608, 8388608, 192, 768, 1048576, 6291456, 4, 128, 16128, 4, 256, 1536, 2048, 64, 768,
  536870912, 0, 4, 4096, 512, 24576, 1048576, 0, 64, 512, 16384, 65536, 131072, 0, 24576, 2097152, 4, 2097152, 4,
  4194304, 16777216, 67108864, 268435456, 24576, 4194304, 536870912, -2147483648, 2, 32, 2, 16384, 2466179, 8388607,
  8388607, 16777215, 8388607, 3, 128, 8448, 98304, 7, 120, 245760, 786432, 131072, 786432, 2, 128, 256, 8192, 65536,
  262144, 6291456, 1536, 8192, 131072, 524288, 1048576, 2097152, 1048576, 4194304, 64, 256, 4096, 2097152, 4194304, 0,
  1592235404, 1536, 131072, 64, 4, 32, 0, 7, 48, 512, 0, 12, 1024, 131072, 262144
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "StringLiteral",
  "S",
  "NCName",
  "QName",
  "CommentContents",
  "NCNameColonStar",
  "StarColonNCName",
  "'*'",
  "EOF",
  "'('",
  "'(:'",
  "')'",
  "'/'",
  "'//'",
  "':)'",
  "'::'",
  "'@'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'ascending'",
  "'attribute'",
  "'case'",
  "'cast'",
  "'castable'",
  "'child'",
  "'collation'",
  "'comment'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'eq'",
  "'every'",
  "'except'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'ge'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'le'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'ne'",
  "'node'",
  "'or'",
  "'order'",
  "'ordered'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'processing-instruction'",
  "'return'",
  "'satisfies'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'text'",
  "'to'",
  "'treat'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'where'",
  "'xquery'",
  "'|'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 1024
    return
      if ($result != 0) then
      (
        $result mod 128 - 1,
        $begin,
        $end - $result idiv 128
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 1024 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 2
    let $i0 := $t * 719 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 10;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 11;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    $state[position() >= $p:l1 and position() <= $p:e2],
    0,
    $state[$p:e2],
    $state[position() >= $p:e2],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    $state[position() < $p:error],
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    $state[position() > $p:error]
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 3) then                                 (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 12) then                           (: ('(' ':') :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l2] != 0) then
      $state[position() >= $p:l2 and position() <= $p:e2]
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 128 + $state[$p:l1],
    $state[position() > $p:lk and position() < $p:l2],
    $match,
    $state[position() > $p:e2]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      $state[position() > $p:lk and position() < $p:l1],
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  element {$name}
  {
    $state[position() > $count]
  }
};

(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(5, $input, $state)           (: CommentContents | ('(' ':') | (':' ')') :)
    return
      if ($state[$p:l1] = 16) then                          (: (':' ')') :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 6) then                       (: CommentContents :)
            let $state := p:shift(6, $input, $state)        (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(12, $input, $state)                 (: ('(' ':') :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(16, $input, $state)                 (: (':' ')') :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(1, $input, $state)           (: END | S^WS | ('(' ':') :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 3) then                       (: S^WS :)
            let $state := p:shift(3, $input, $state)        (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse DescendantRootPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DescendantRootPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(15, $input, $state)                 (: '//' :)
  let $state := p:lookahead1W(0, $input, $state)            (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-RelativePathPattern($input, $state)
  return p:reduce($state, "DescendantRootPattern", $count)
};

(:~
 : Parse DescendantPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DescendantPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(15, $input, $state)                 (: '//' :)
  return p:reduce($state, "DescendantPattern", $count)
};

(:~
 : Parse StarColonNCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StarColonNCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(8, $input, $state)                  (: StarColonNCName^Token :)
  return p:reduce($state, "StarColonNCName", $count)
};

(:~
 : Parse NCNameColonStar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCNameColonStar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(7, $input, $state)                  (: NCNameColonStar^Token :)
  return p:reduce($state, "NCNameColonStar", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: NCNameColonStar^Token :)
      let $state := p:parse-NCNameColonStar($input, $state)
      return $state
    else if ($state[$p:l1] = 8) then                        (: StarColonNCName^Token :)
      let $state := p:parse-StarColonNCName($input, $state)
      return $state
    else if ($state[$p:l1] = 9) then                        (: Star^Token :)
      let $state := p:parse-Star($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(63, $input, $state)                 (: 'node' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(78, $input, $state)                 (: 'text' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(29, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 21) then                            (: 'and' :)
      let $state := p:shift(21, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: 'ascending' :)
      let $state := p:shift(22, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: 'case' :)
      let $state := p:shift(24, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: 'cast' :)
      let $state := p:shift(25, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'castable' :)
      let $state := p:shift(26, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: 'collation' :)
      let $state := p:shift(28, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: 'default' :)
      let $state := p:shift(31, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'descending' :)
      let $state := p:shift(34, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'div' :)
      let $state := p:shift(35, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: 'else' :)
      let $state := p:shift(39, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 40) then                       (: 'empty' :)
      let $state := p:shift(40, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: 'eq' :)
      let $state := p:shift(42, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 44) then                       (: 'except' :)
      let $state := p:shift(44, $input, $state)             (: 'except' :)
      return $state
    else if ($state[$p:l1] = 47) then                       (: 'for' :)
      let $state := p:shift(47, $input, $state)             (: 'for' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: 'ge' :)
      let $state := p:shift(48, $input, $state)             (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'gt' :)
      let $state := p:shift(49, $input, $state)             (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'idiv' :)
      let $state := p:shift(50, $input, $state)             (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: 'instance' :)
      let $state := p:shift(53, $input, $state)             (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'intersect' :)
      let $state := p:shift(54, $input, $state)             (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'is' :)
      let $state := p:shift(55, $input, $state)             (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'le' :)
      let $state := p:shift(57, $input, $state)             (: 'le' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: 'let' :)
      let $state := p:shift(58, $input, $state)             (: 'let' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'lt' :)
      let $state := p:shift(59, $input, $state)             (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: 'mod' :)
      let $state := p:shift(60, $input, $state)             (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'ne' :)
      let $state := p:shift(62, $input, $state)             (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 64) then                       (: 'or' :)
      let $state := p:shift(64, $input, $state)             (: 'or' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'order' :)
      let $state := p:shift(65, $input, $state)             (: 'order' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'return' :)
      let $state := p:shift(71, $input, $state)             (: 'return' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'satisfies' :)
      let $state := p:shift(72, $input, $state)             (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'stable' :)
      let $state := p:shift(77, $input, $state)             (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'to' :)
      let $state := p:shift(79, $input, $state)             (: 'to' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'treat' :)
      let $state := p:shift(80, $input, $state)             (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'union' :)
      let $state := p:shift(82, $input, $state)             (: 'union' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'where' :)
      let $state := p:shift(85, $input, $state)             (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(4, $input, $state)              (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(70, $input, $state)                 (: 'processing-instruction' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(11, $input, $state)           (: StringLiteral | S^WS | NCName^Token | ('(' ':') | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 13) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 2) then                         (: StringLiteral :)
          let $state := p:shift(2, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(23, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(13, $input, $state)           (: S^WS | QName^Token | Star^Token | ('(' ':') | ')' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 13) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 9) then                         (: Star^Token :)
          let $state := p:parse-Star($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-QName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse Star.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Star($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(9, $input, $state)                  (: Star^Token :)
  return p:reduce($state, "Star", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 19) then                            (: 'ancestor' :)
      let $state := p:shift(19, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 20) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(20, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 21) then                       (: 'and' :)
      let $state := p:shift(21, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 22) then                       (: 'ascending' :)
      let $state := p:shift(22, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 24) then                       (: 'case' :)
      let $state := p:shift(24, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: 'cast' :)
      let $state := p:shift(25, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'castable' :)
      let $state := p:shift(26, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'child' :)
      let $state := p:shift(27, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 28) then                       (: 'collation' :)
      let $state := p:shift(28, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 30) then                       (: 'declare' :)
      let $state := p:shift(30, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 31) then                       (: 'default' :)
      let $state := p:shift(31, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 32) then                       (: 'descendant' :)
      let $state := p:shift(32, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 33) then                       (: 'descendant-or-self' :)
      let $state := p:shift(33, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 34) then                       (: 'descending' :)
      let $state := p:shift(34, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: 'div' :)
      let $state := p:shift(35, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 36) then                       (: 'document' :)
      let $state := p:shift(36, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 39) then                       (: 'else' :)
      let $state := p:shift(39, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 40) then                       (: 'empty' :)
      let $state := p:shift(40, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 42) then                       (: 'eq' :)
      let $state := p:shift(42, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 43) then                       (: 'every' :)
      let $state := p:shift(43, $input, $state)             (: 'every' :)
      return $state
    else if ($state[$p:l1] = 44) then                       (: 'except' :)
      let $state := p:shift(44, $input, $state)             (: 'except' :)
      return $state
    else if ($state[$p:l1] = 45) then                       (: 'following' :)
      let $state := p:shift(45, $input, $state)             (: 'following' :)
      return $state
    else if ($state[$p:l1] = 46) then                       (: 'following-sibling' :)
      let $state := p:shift(46, $input, $state)             (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 47) then                       (: 'for' :)
      let $state := p:shift(47, $input, $state)             (: 'for' :)
      return $state
    else if ($state[$p:l1] = 48) then                       (: 'ge' :)
      let $state := p:shift(48, $input, $state)             (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 49) then                       (: 'gt' :)
      let $state := p:shift(49, $input, $state)             (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: 'idiv' :)
      let $state := p:shift(50, $input, $state)             (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 52) then                       (: 'import' :)
      let $state := p:shift(52, $input, $state)             (: 'import' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: 'instance' :)
      let $state := p:shift(53, $input, $state)             (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: 'intersect' :)
      let $state := p:shift(54, $input, $state)             (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 55) then                       (: 'is' :)
      let $state := p:shift(55, $input, $state)             (: 'is' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: 'le' :)
      let $state := p:shift(57, $input, $state)             (: 'le' :)
      return $state
    else if ($state[$p:l1] = 58) then                       (: 'let' :)
      let $state := p:shift(58, $input, $state)             (: 'let' :)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'lt' :)
      let $state := p:shift(59, $input, $state)             (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 60) then                       (: 'mod' :)
      let $state := p:shift(60, $input, $state)             (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 61) then                       (: 'module' :)
      let $state := p:shift(61, $input, $state)             (: 'module' :)
      return $state
    else if ($state[$p:l1] = 62) then                       (: 'ne' :)
      let $state := p:shift(62, $input, $state)             (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 64) then                       (: 'or' :)
      let $state := p:shift(64, $input, $state)             (: 'or' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'order' :)
      let $state := p:shift(65, $input, $state)             (: 'order' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ordered' :)
      let $state := p:shift(66, $input, $state)             (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'parent' :)
      let $state := p:shift(67, $input, $state)             (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 68) then                       (: 'preceding' :)
      let $state := p:shift(68, $input, $state)             (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'preceding-sibling' :)
      let $state := p:shift(69, $input, $state)             (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'return' :)
      let $state := p:shift(71, $input, $state)             (: 'return' :)
      return $state
    else if ($state[$p:l1] = 72) then                       (: 'satisfies' :)
      let $state := p:shift(72, $input, $state)             (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 75) then                       (: 'self' :)
      let $state := p:shift(75, $input, $state)             (: 'self' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'some' :)
      let $state := p:shift(76, $input, $state)             (: 'some' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'stable' :)
      let $state := p:shift(77, $input, $state)             (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'to' :)
      let $state := p:shift(79, $input, $state)             (: 'to' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'treat' :)
      let $state := p:shift(80, $input, $state)             (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'union' :)
      let $state := p:shift(82, $input, $state)             (: 'union' :)
      return $state
    else if ($state[$p:l1] = 83) then                       (: 'unordered' :)
      let $state := p:shift(83, $input, $state)             (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 84) then                       (: 'validate' :)
      let $state := p:shift(84, $input, $state)             (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'where' :)
      let $state := p:shift(85, $input, $state)             (: 'where' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'xquery' :)
      let $state := p:shift(86, $input, $state)             (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 23) then                            (: 'attribute' :)
      let $state := p:shift(23, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'comment' :)
      let $state := p:shift(29, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 37) then                       (: 'document-node' :)
      let $state := p:shift(37, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'element' :)
      let $state := p:shift(38, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 41) then                       (: 'empty-sequence' :)
      let $state := p:shift(41, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 51) then                       (: 'if' :)
      let $state := p:shift(51, $input, $state)             (: 'if' :)
      return $state
    else if ($state[$p:l1] = 56) then                       (: 'item' :)
      let $state := p:shift(56, $input, $state)             (: 'item' :)
      return $state
    else if ($state[$p:l1] = 63) then                       (: 'node' :)
      let $state := p:shift(63, $input, $state)             (: 'node' :)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'processing-instruction' :)
      let $state := p:shift(70, $input, $state)             (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'schema-attribute' :)
      let $state := p:shift(73, $input, $state)             (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 74) then                       (: 'schema-element' :)
      let $state := p:shift(74, $input, $state)             (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'text' :)
      let $state := p:shift(78, $input, $state)             (: 'text' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'typeswitch' :)
      let $state := p:shift(81, $input, $state)             (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(38, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(13, $input, $state)           (: S^WS | QName^Token | Star^Token | ('(' ':') | ')' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 13) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 9) then                         (: Star^Token :)
          let $state := p:parse-Star($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-QName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(37, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(2, $input, $state)            (: S^WS | '(' | ('(' ':') :)
  let $state := p:shift(11, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(3, $input, $state)            (: S^WS | ('(' ':') | ')' :)
  let $state := p:shift(13, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 37) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 38) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 23) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 70) then                       (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 29) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: QName^Token | NCNameColonStar^Token |
                                                               StarColonNCName^Token | Star^Token | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'case' | 'cast' | 'castable' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 23                                  (: 'comment' :)
     or $state[$p:l1] = 29                                  (: 'document-node' :)
     or $state[$p:l1] = 37                                  (: 'element' :)
     or $state[$p:l1] = 38                                  (: 'node' :)
     or $state[$p:l1] = 63                                  (: 'processing-instruction' :)
     or $state[$p:l1] = 70                                  (: 'text' :)
     or $state[$p:l1] = 78) then                            (: 'text' :)
      let $state := p:lookahead2W(8, $input, $state)        (: S^WS | EOF | '(' | ('(' ':') | '/' | '//' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 1431                                (: 'attribute' '(' :)
     or $state[$p:lk] = 1437                                (: 'comment' '(' :)
     or $state[$p:lk] = 1445                                (: 'document-node' '(' :)
     or $state[$p:lk] = 1446                                (: 'element' '(' :)
     or $state[$p:lk] = 1471                                (: 'node' '(' :)
     or $state[$p:lk] = 1478                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 1486) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse AttributeAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 23) then                            (: 'attribute' :)
      let $state := p:shift(23, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(4, $input, $state)        (: S^WS | ('(' ':') | '::' :)
      let $state := p:shift(17, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(18, $input, $state)             (: '@' :)
      return $state
  return p:reduce($state, "AttributeAxis", $count)
};

(:~
 : Parse ChildAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ChildAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(27, $input, $state)                 (: 'child' :)
  let $state := p:lookahead1W(4, $input, $state)            (: S^WS | ('(' ':') | '::' :)
  let $state := p:shift(17, $input, $state)                 (: '::' :)
  return p:reduce($state, "ChildAxis", $count)
};

(:~
 : Parse PatternStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PatternStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(14, $input, $state)           (: S^WS | QName^Token | NCNameColonStar^Token |
                                                               StarColonNCName^Token | Star^Token | ('(' ':') | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'case' | 'cast' | 'castable' | 'child' |
                                                               'collation' | 'comment' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'document-node' | 'element' |
                                                               'else' | 'empty' | 'empty-sequence' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'if' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'module' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'return' | 'satisfies' | 'schema-attribute' |
                                                               'schema-element' | 'self' | 'some' | 'stable' | 'text' |
                                                               'to' | 'treat' | 'typeswitch' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 23) then                            (: 'attribute' :)
      let $state := p:lookahead2W(10, $input, $state)       (: S^WS | EOF | '(' | ('(' ':') | '/' | '//' | '::' | '|' :)
      return $state
    else if ($state[$p:l1] = 27) then                       (: 'child' :)
      let $state := p:lookahead2W(9, $input, $state)        (: S^WS | EOF | ('(' ':') | '/' | '//' | '::' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 18                             (: '@' :)
          or $state[$p:lk] = 2199                           (: 'attribute' '::' :)
          or $state[$p:lk] = 2203) then                     (: 'child' '::' :)
      let $state :=
        if ($state[$p:l1] = 27) then                        (: 'child' :)
          let $state := p:parse-ChildAxis($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-AttributeAxis($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(0, $input, $state)            (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "PatternStep", $count)
};

(:~
 : Parse the 1st loop of production RelativePathPattern (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathPattern-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(7, $input, $state)          (: S^WS | EOF | ('(' ':') | '/' | '//' | '|' :)
    return
      if ($state[$p:l1] != 14                               (: '/' :)
      and $state[$p:l1] != 15) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: '/' :)
            let $state := p:shift(14, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-DescendantPattern($input, $state)
            return $state
        let $state := p:lookahead1W(0, $input, $state)      (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-PatternStep($input, $state)
        return p:parse-RelativePathPattern-1($input, $state)
};

(:~
 : Parse RelativePathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PatternStep($input, $state)
  let $state := p:parse-RelativePathPattern-1($input, $state)
  return p:reduce($state, "RelativePathPattern", $count)
};

(:~
 : Parse RootPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RootPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(14, $input, $state)                 (: '/' :)
  let $state := p:lookahead1W(15, $input, $state)           (: S^WS | QName^Token | NCNameColonStar^Token |
                                                               StarColonNCName^Token | Star^Token | EOF | ('(' ':') |
                                                               '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' |
                                                               '|' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 10                            (: EOF :)
         and $state[$p:l1] != 87) then                      (: '|' :)
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RootPattern", $count)
};

(:~
 : Parse PathPattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathPattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(16, $input, $state)           (: S^WS | QName^Token | NCNameColonStar^Token |
                                                               StarColonNCName^Token | Star^Token | ('(' ':') | '/' |
                                                               '//' | '@' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'case' | 'cast' |
                                                               'castable' | 'child' | 'collation' | 'comment' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'node' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' |
                                                               'processing-instruction' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                               'union' | 'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 14) then                            (: '/' :)
      let $state := p:parse-RootPattern($input, $state)
      return $state
    else if ($state[$p:l1] = 15) then                       (: '//' :)
      let $state := p:parse-DescendantRootPattern($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathPattern($input, $state)
      return $state
  return p:reduce($state, "PathPattern", $count)
};

(:~
 : Parse the 1st loop of production Pattern (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pattern-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(6, $input, $state)          (: S^WS | EOF | ('(' ':') | '|' :)
    return
      if ($state[$p:l1] != 87) then                         (: '|' :)
        $state
      else
        let $state := p:shift(87, $input, $state)           (: '|' :)
        let $state := p:lookahead1W(0, $input, $state)      (: EPSILON | S^WS | ('(' ':') :)
        let $state := p:parse-PathPattern($input, $state)
        return p:parse-Pattern-1($input, $state)
};

(:~
 : Parse Pattern.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pattern($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(0, $input, $state)            (: EPSILON | S^WS | ('(' ':') :)
  let $state := p:parse-PathPattern($input, $state)
  let $state := p:parse-Pattern-1($input, $state)
  let $state := p:shift(10, $input, $state)                 (: EOF :)
  return p:reduce($state, "Pattern", $count)
};

(:~
 : Parse start symbol Pattern from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-Pattern($s as xs:string) as item()*
{
  let $state := p:parse-Pattern($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
};

(: End :)
