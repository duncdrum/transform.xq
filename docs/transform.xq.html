<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta http-equiv="Generator" content="xquerydoc - https://github.com/xquery/xquerydoc"/><meta http-equiv="Authors" content="Copyright 2011 - John Snelson, James Fuller"/><title>xqDoc - </title><style type="text/css">
          body {
          font-family: Helvetica;
          padding: 0.5em  1em;
          }
          pre {
          font-family: Inconsolata, Consolas, monospace;
          }
          ol.results {
          padding-left: 0;
          }
          .footer {
          text-align:right;
          border-top: solid 4px;
          padding: 0.25em 0.5em;
          font-size: 85%;
          color: #999;
          }
          li.result {
          list-style-position: inside;
          list-style: none;
          height:140px;
          }
          h2 {
          display: inline-block;
          margin: 0;
          }

          h2 a,
          .result h3 a {
          text-decoration: inherit;
          color: inherit;
          }
          h3{
	  font-size: 140%;
	  background-color: #aaa;
	  border-bottom: 1px solid #000;
	  width: 100%;
	  }
          h4{
	  font-size: 100%;
	  background-color: #ddd;
	  width: 90%;
	  }

          .namespace {
          color: #999;
          }
          .namespace:before {
          content: "{";
          }
          .namespace:after {
          content: "}";
          }
          table{
          width:75%;
          float:right;
          }
          td {
          height:100px;
          width:50%;
          vertical-align:text-top;
          }
        </style><script src="lib/prettify.js" type="text/javascript"> </script><script src="lib/lang-xq.js" type="text/javascript"> </script><link rel="stylesheet" type="text/css" href="lib/prettify.css"/></head><body class="home"><div style="text-align:right;"><a href="index.html">XQuery API index</a></div><div id="main"><h1><span class="namespace">http://snelson.org.uk/functions/transform</span>  library module </h1><p>transform.xq - An extensible transformation library for XQuery 3.0</p><div><h3>Variables</h3><h4><pre class="prettyprint lang-xq"><u>Variable:</u> $magic as  element()</pre></h4><p>Magic value to get a mode function to return its map of rules</p></div><div><h3>Functions</h3><h4><pre class="prettyprint lang-xq"><u>Function:</u> mode(
  $rules as (function(xs:string) as function(*)?)*) as  function(node()*) as item()*</pre></h4><p>Returns the mode function, that performs the transformation</p><h5>Params</h5><ul><li>rules as  (function(xs:string) as function(*)?)*</li></ul><h5>Returns</h5><ul><li> function(node()*) as item()*</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> extend-mode(
  $mode as function(node()*) as item()*,
  $rules as (function(xs:string) as function(*)?)*) as  function(node()*) as item()*</pre></h4><h5>Params</h5><ul><li>mode as  function(node()*) as item()*</li><li>rules as  (function(xs:string) as function(*)?)*</li></ul><h5>Returns</h5><ul><li> function(node()*) as item()*</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> named-mode(
  $name as xs:string) as  function(node()*) as item()*</pre></h4><p>Returns a mode function constructed from the functions at runtime annotated with the given name</p><h5>Params</h5><ul><li>name as  xs:string</li></ul><h5>Returns</h5><ul><li> function(node()*) as item()*</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> functions() as  function() as function(*)*?</pre></h4><h5>Returns</h5><ul><li> function() as function(*)*?</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> annotation() as  function(function(*),xs:QName) as item()*?</pre></h4><h5>Returns</h5><ul><li> function(function(*),xs:QName) as item()*?</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> add-rule($map,$rule)</pre></h4><h5>Params</h5><ul><li>map as </li><li>rule as </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> add($map,$key,$rule)</pre></h4><h5>Params</h5><ul><li>map as </li><li>key as </li><li>rule as </li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> run-mode(
  $map as function() as item()+,
  $nodes as node()*) as  item()*</pre></h4><h5>Params</h5><ul><li>map as  function() as item()+</li><li>nodes as  node()*</li></ul><h5>Returns</h5><ul><li> item()*</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> _run-mode(
  $map as function() as item()+,
  $nodes as node()*) as  item()*</pre></h4><h5>Params</h5><ul><li>map as  function() as item()+</li><li>nodes as  node()*</li></ul><h5>Returns</h5><ul><li> item()*</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> rule(
  $pattern as xs:string,
  $action as function(function(node()*) as item()*,node()) as item()*) as  function(xs:string) as function(*)?</pre></h4><h5>Params</h5><ul><li>pattern as  xs:string</li><li>action as  function(function(node()*) as item()*,node()) as item()*</li></ul><h5>Returns</h5><ul><li> function(xs:string) as function(*)?</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> rule(
  $pattern as xs:string,
  $action as function(function(node()*) as item()*,node()) as item()*,
  $resolver as item()) as  function(xs:string) as function(*)?</pre></h4><h5>Params</h5><ul><li>pattern as  xs:string</li><li>action as  function(function(node()*) as item()*,node()) as item()*</li><li>resolver as  item()</li></ul><h5>Returns</h5><ul><li> function(xs:string) as function(*)?</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> predicate-rule(
  $predicate as function(*),
  $action as function(function(node()*) as item()*,node()) as item()*) as  function(xs:string) as function(*)?</pre></h4><p>Returns the predicate and action wrapped as a single item</p><h5>Params</h5><ul><li>predicate as  function(*)</li><li>action as  function(function(node()*) as item()*,node()) as item()*</li></ul><h5>Returns</h5><ul><li> function(xs:string) as function(*)?</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> resolver(
  $element as element()) as  function(xs:string) as xs:QName</pre></h4><h5>Params</h5><ul><li>element as  element()</li></ul><h5>Returns</h5><ul><li> function(xs:string) as xs:QName</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> pattern(
  $pattern as xs:string) as  function(*)</pre></h4><h5>Params</h5><ul><li>pattern as  xs:string</li></ul><h5>Returns</h5><ul><li> function(*)</li></ul><h4><pre class="prettyprint lang-xq"><u>Function:</u> pattern(
  $pattern as xs:string,
  $resolver as item()) as  function(*)</pre></h4><h5>Params</h5><ul><li>pattern as  xs:string</li><li>resolver as  item()</li></ul><h5>Returns</h5><ul><li> function(*)</li></ul></div><div><h3>Original Source Code</h3><pre class="prettyprint lang-xq">xquery version "3.0-ml";

(:
 : Copyright (c) 2011 John Snelson
 :
 : Licensed under the Apache License, Version 2.0 (the "License");
 : you may not use this file except in compliance with the License.
 : You may obtain a copy of the License at
 :
 :     http://www.apache.org/licenses/LICENSE-2.0
 :
 : Unless required by applicable law or agreed to in writing, software
 : distributed under the License is distributed on an "AS IS" BASIS,
 : WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 : See the License for the specific language governing permissions and
 : limitations under the License.
 :)

(:~ transform.xq - An extensible transformation library for XQuery 3.0 :)
module namespace tfm = "http://snelson.org.uk/functions/transform";

import module namespace pat = "http://snelson.org.uk/functions/patterns" at "lib/compile_pattern.xq";
import module namespace map = "http://snelson.org.uk/functions/map" at "lib/map.xq"; (: TBD private annotation :)

declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~ Magic value to get a mode function to return its map of rules :)
declare variable $tfm:magic as element() := &lt;magic/&gt;;

(:~ Returns the mode function, that performs the transformation :)
declare function tfm:mode(
  $rules as (function(xs:string) as function(*)?)*
) as function(node()*) as item()*
{
  let $map := fold-left(tfm:add-rule#2, map:create(), $rules)
  return tfm:run-mode($map,?)
};

declare function tfm:extend-mode(
  $mode as function(node()*) as item()*,
  $rules as (function(xs:string) as function(*)?)*
) as function(node()*) as item()*
{
  let $map := $mode($tfm:magic)
  let $map := fold-left(tfm:add-rule#2, $map, $rules)
  return tfm:run-mode($map,?)
};

(:~ Returns a mode function constructed from the functions
at runtime annotated with the given name :)
declare function tfm:named-mode(
  $name as xs:string
) as function(node()*) as item()*
{
  let $functions := tfm:functions()
  let $annotation := tfm:annotation()
  return
    if(empty($functions) or empty($annotation)) then
      error(xs:QName("tfm:NOTSUPPORTED"), "Named modes are not supported on your platform")
    else tfm:mode(
      for $f in $functions()
      where $annotation($f, xs:QName("tfm:mode")) = $name
      return
        let $predicate := $annotation($f, xs:QName("tfm:pattern"))
        return
          if(empty($predicate)) then error(xs:QName("tfm:NOPATTERN"),
            "No pattern specified on function: " || function-name($f) || "#" || function-arity($f))
          else tfm:rule($predicate, $f)
    )
};

declare function tfm:functions() as function() as function(*)*?
{
  (
    function-lookup(fn:QName("http://marklogic.com/xdmp","xdmp:functions"),0)
  )[1]
};

declare function tfm:annotation() as function(function(*),xs:QName) as item()*?
{
  (
    function-lookup(fn:QName("http://marklogic.com/xdmp","xdmp:annotation"),0)
  )[1]
};

declare function tfm:add-rule($map,$rule)
{
  typeswitch($rule("predicate"))
    case function(element()) as xs:boolean
      return tfm:add($map,"element",$rule)
    case function(attribute()) as xs:boolean
      return tfm:add($map,"attribute",$rule)
    case function(document-node()) as xs:boolean
      return tfm:add($map,"document",$rule)
    case function(comment()) as xs:boolean
      return tfm:add($map,"comment",$rule)
    case function(text()) as xs:boolean
      return tfm:add($map,"text",$rule)
    case function(processing-instruction()) as xs:boolean
      return tfm:add($map,"pi",$rule)
    case $p as function(*) return
      if(function-arity($p) ne 1) then error(xs:QName("tfm:BADPREDICATE"),
        "The predicate should have arity 1")
      else (
        tfm:add($map,"element",$rule),
        tfm:add($map,"attribute",$rule),
        tfm:add($map,"document",$rule),
        tfm:add($map,"comment",$rule),
        tfm:add($map,"text",$rule),
        tfm:add($map,"pi",$rule),
        tfm:add($map,"node",$rule)
      )
    default return error(xs:QName("tfm:BADPREDICATE"),
      "The predicate should be a function")
};

declare function tfm:add($map,$key,$rule)
{
  map:put($map,$key,($rule,map:get($map,$key)))
};

declare function tfm:run-mode(
  $map as function() as item()+,
  $nodes as node()*
) as item()*
{
  if($nodes[1] is $tfm:magic) then $map
  else tfm:_run-mode($map,$nodes)
};

declare function tfm:_run-mode(
  $map as function() as item()+,
  $nodes as node()*
) as item()*
{
  let $m := tfm:_run-mode($map,?)
  for $n in $nodes
  let $rules :=
    typeswitch($n)
      case element() return map:get($map,"element")
      case attribute() return map:get($map,"attribute")
      case document-node() return map:get($map,"document")
      case comment() return map:get($map,"comment")
      case text() return map:get($map,"text")
      case processing-instruction() return map:get($map,"pi")
      default return map:get($map,"node")
  let $r :=
    fold-left(function($found, $r) {
        if(exists($found)) then $found
        else if(try { $r("predicate")($n) } catch($e) { false() }) then $r (: TBD 3.0 try/catch :)
        else ()
      }, (), $rules)
  return
    if(exists($r)) then $r("action")($m,$n)
    else (: default rule :)
      typeswitch($n)
        case document-node() return $n/node() ! $m(.) (: TBD multi-way typeswitch :)
        case element() return $n/node() ! $m(.)
        case text() return text { $n }
        case attribute() return text { $n }
        default return ()
};

declare function tfm:rule(
  $pattern as xs:string,
  $action as function(function(node()*) as item()*,node()) as item()*
) as function(xs:string) as function(*)?
{
  tfm:predicate-rule(tfm:pattern($pattern), $action)
};

declare function tfm:rule(
  $pattern as xs:string,
  $action as function(function(node()*) as item()*,node()) as item()*,
  $resolver as item()
) as function(xs:string) as function(*)?
{
  tfm:predicate-rule(tfm:pattern($pattern,$resolver), $action)
};

(:~ Returns the predicate and action wrapped as a single item :)
declare function tfm:predicate-rule(
  $predicate as function(*),
  $action as function(function(node()*) as item()*,node()) as item()*
) as function(xs:string) as function(*)?
{
  function($k as xs:string) as function(*)?
  {
    (: TBD switch :)
    (: switch($k) :)
    (: case "predicate" return $predicate :)
    (: case "action" return $action :)
    (: default return () :)

    if($k eq "predicate") then $predicate
    else if($k eq "action") then $action
    else ()
  }
};

declare function tfm:resolver(
  $element as element()
) as function(xs:string) as xs:QName
{
  resolve-QName(?, $element)
};

declare function tfm:pattern(
  $pattern as xs:string
) as function(*)
{
  let $ns := &lt;ns
      xmlns:fn="http://www.w3.org/2005/xpath-functions"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:xhtml="http://www.w3.org/1999/xhtml"
    /&gt;
  return tfm:pattern($pattern,$ns)
};

declare function tfm:pattern(
  $pattern as xs:string,
  $resolver as item()
) as function(*)
{
  let $r :=
    typeswitch($resolver)
      case function(xs:string) as xs:QName return $resolver
      case $e as element() return tfm:resolver($e)
      default return error(xs:QName("tfm:BADRESOLVER"),
        "The resolver should either be of type element() or function(xs:string) as xs:QName")
  return pat:compile-pattern($pattern, $r)
};
</pre></div><br/><div class="footer"><p style="text-align:right"><i/> |
          generated by xquerydoc <a href="https://github.com/xquery/xquerydoc" target="xquerydoc">https://github.com/xquery/xquerydoc</a></p></div></div><script type="application/javascript">
	  window.onload = function(){ prettyPrint(); }
	</script></body></html>